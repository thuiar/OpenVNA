{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { defineComponent, ref, computed, unref, watch, nextTick, openBlock, createElementBlock, normalizeClass, createElementVNode, toDisplayString, createCommentVNode, Fragment, renderList, createVNode } from 'vue';\nimport dayjs from 'dayjs';\nimport { flatten } from 'lodash-unified';\nimport '../../../../hooks/index.mjs';\nimport '../../../../utils/index.mjs';\nimport { basicDateTableProps } from '../props/basic-date-table.mjs';\nimport { buildPickerTable } from '../utils.mjs';\nimport ElDatePickerCell from './basic-cell-render.mjs';\nimport _export_sfc from '../../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { useLocale } from '../../../../hooks/use-locale/index.mjs';\nimport { castArray } from '../../../../utils/arrays.mjs';\nconst _hoisted_1 = [\"aria-label\"];\nconst _hoisted_2 = {\n  key: 0,\n  scope: \"col\"\n};\nconst _hoisted_3 = [\"aria-label\"];\nconst _hoisted_4 = [\"aria-current\", \"aria-selected\", \"tabindex\"];\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  __name: \"basic-date-table\",\n  props: basicDateTableProps,\n  emits: [\"changerange\", \"pick\", \"select\"],\n  setup(__props, {\n    expose,\n    emit\n  }) {\n    const props = __props;\n    const ns = useNamespace(\"date-table\");\n    const {\n      t,\n      lang\n    } = useLocale();\n    const tbodyRef = ref();\n    const currentCellRef = ref();\n    const lastRow = ref();\n    const lastColumn = ref();\n    const tableRows = ref([[], [], [], [], [], []]);\n    let focusWithClick = false;\n    const firstDayOfWeek = props.date.$locale().weekStart || 7;\n    const WEEKS_CONSTANT = props.date.locale(\"en\").localeData().weekdaysShort().map(_ => _.toLowerCase());\n    const offsetDay = computed(() => {\n      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;\n    });\n    const startDate = computed(() => {\n      const startDayOfMonth = props.date.startOf(\"month\");\n      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, \"day\");\n    });\n    const WEEKS = computed(() => {\n      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);\n    });\n    const hasCurrent = computed(() => {\n      return flatten(rows.value).some(row => {\n        return row.isCurrent;\n      });\n    });\n    const days = computed(() => {\n      const startOfMonth = props.date.startOf(\"month\");\n      const startOfMonthDay = startOfMonth.day() || 7;\n      const dateCountOfMonth = startOfMonth.daysInMonth();\n      const dateCountOfLastMonth = startOfMonth.subtract(1, \"month\").daysInMonth();\n      return {\n        startOfMonthDay,\n        dateCountOfMonth,\n        dateCountOfLastMonth\n      };\n    });\n    const selectedDate = computed(() => {\n      return props.selectionMode === \"dates\" ? castArray(props.parsedValue) : [];\n    });\n    const setDateText = (cell, {\n      count,\n      rowIndex,\n      columnIndex\n    }) => {\n      const {\n        startOfMonthDay,\n        dateCountOfMonth,\n        dateCountOfLastMonth\n      } = unref(days);\n      const offset = unref(offsetDay);\n      if (rowIndex >= 0 && rowIndex <= 1) {\n        const numberOfDaysFromPreviousMonth = startOfMonthDay + offset < 0 ? 7 + startOfMonthDay + offset : startOfMonthDay + offset;\n        if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {\n          cell.text = count;\n          return true;\n        } else {\n          cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - columnIndex % 7) + 1 + rowIndex * 7;\n          cell.type = \"prev-month\";\n        }\n      } else {\n        if (count <= dateCountOfMonth) {\n          cell.text = count;\n        } else {\n          cell.text = count - dateCountOfMonth;\n          cell.type = \"next-month\";\n        }\n        return true;\n      }\n      return false;\n    };\n    const setCellMetadata = (cell, {\n      columnIndex,\n      rowIndex\n    }, count) => {\n      const {\n        disabledDate,\n        cellClassName\n      } = props;\n      const _selectedDate = unref(selectedDate);\n      const shouldIncrement = setDateText(cell, {\n        count,\n        rowIndex,\n        columnIndex\n      });\n      const cellDate = cell.dayjs.toDate();\n      cell.selected = _selectedDate.find(d => d.valueOf() === cell.dayjs.valueOf());\n      cell.isSelected = !!cell.selected;\n      cell.isCurrent = isCurrent(cell);\n      cell.disabled = disabledDate == null ? void 0 : disabledDate(cellDate);\n      cell.customClass = cellClassName == null ? void 0 : cellClassName(cellDate);\n      return shouldIncrement;\n    };\n    const setRowMetadata = row => {\n      if (props.selectionMode === \"week\") {\n        const [start, end] = props.showWeekNumber ? [1, 7] : [0, 6];\n        const isActive = isWeekActive(row[start + 1]);\n        row[start].inRange = isActive;\n        row[start].start = isActive;\n        row[end].inRange = isActive;\n        row[end].end = isActive;\n      }\n    };\n    const rows = computed(() => {\n      const {\n        minDate,\n        maxDate,\n        rangeState,\n        showWeekNumber\n      } = props;\n      const offset = offsetDay.value;\n      const rows_ = tableRows.value;\n      const dateUnit = \"day\";\n      let count = 1;\n      if (showWeekNumber) {\n        for (let rowIndex = 0; rowIndex < 6; rowIndex++) {\n          if (!rows_[rowIndex][0]) {\n            rows_[rowIndex][0] = {\n              type: \"week\",\n              text: startDate.value.add(rowIndex * 7 + 1, dateUnit).week()\n            };\n          }\n        }\n      }\n      buildPickerTable({\n        row: 6,\n        column: 7\n      }, rows_, {\n        startDate: minDate,\n        columnIndexOffset: showWeekNumber ? 1 : 0,\n        nextEndDate: rangeState.endDate || maxDate || rangeState.selecting && minDate || null,\n        now: dayjs().locale(unref(lang)).startOf(dateUnit),\n        unit: dateUnit,\n        relativeDateGetter: idx => startDate.value.add(idx - offset, dateUnit),\n        setCellMetadata: (...args) => {\n          if (setCellMetadata(...args, count)) {\n            count += 1;\n          }\n        },\n        setRowMetadata\n      });\n      return rows_;\n    });\n    watch(() => props.date, async () => {\n      var _a, _b;\n      if ((_a = tbodyRef.value) == null ? void 0 : _a.contains(document.activeElement)) {\n        await nextTick();\n        (_b = currentCellRef.value) == null ? void 0 : _b.focus();\n      }\n    });\n    const focus = async () => {\n      var _a;\n      (_a = currentCellRef.value) == null ? void 0 : _a.focus();\n    };\n    const isNormalDay = (type = \"\") => {\n      return [\"normal\", \"today\"].includes(type);\n    };\n    const isCurrent = cell => {\n      return props.selectionMode === \"date\" && isNormalDay(cell.type) && cellMatchesDate(cell, props.parsedValue);\n    };\n    const cellMatchesDate = (cell, date) => {\n      if (!date) return false;\n      return dayjs(date).locale(lang.value).isSame(props.date.date(Number(cell.text)), \"day\");\n    };\n    const getCellClasses = cell => {\n      const classes = [];\n      if (isNormalDay(cell.type) && !cell.disabled) {\n        classes.push(\"available\");\n        if (cell.type === \"today\") {\n          classes.push(\"today\");\n        }\n      } else {\n        classes.push(cell.type);\n      }\n      if (isCurrent(cell)) {\n        classes.push(\"current\");\n      }\n      if (cell.inRange && (isNormalDay(cell.type) || props.selectionMode === \"week\")) {\n        classes.push(\"in-range\");\n        if (cell.start) {\n          classes.push(\"start-date\");\n        }\n        if (cell.end) {\n          classes.push(\"end-date\");\n        }\n      }\n      if (cell.disabled) {\n        classes.push(\"disabled\");\n      }\n      if (cell.selected) {\n        classes.push(\"selected\");\n      }\n      if (cell.customClass) {\n        classes.push(cell.customClass);\n      }\n      return classes.join(\" \");\n    };\n    const getDateOfCell = (row, column) => {\n      const offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;\n      return startDate.value.add(offsetFromStart, \"day\");\n    };\n    const handleMouseMove = event => {\n      var _a;\n      if (!props.rangeState.selecting) return;\n      let target = event.target;\n      if (target.tagName === \"SPAN\") {\n        target = (_a = target.parentNode) == null ? void 0 : _a.parentNode;\n      }\n      if (target.tagName === \"DIV\") {\n        target = target.parentNode;\n      }\n      if (target.tagName !== \"TD\") return;\n      const row = target.parentNode.rowIndex - 1;\n      const column = target.cellIndex;\n      if (rows.value[row][column].disabled) return;\n      if (row !== lastRow.value || column !== lastColumn.value) {\n        lastRow.value = row;\n        lastColumn.value = column;\n        emit(\"changerange\", {\n          selecting: true,\n          endDate: getDateOfCell(row, column)\n        });\n      }\n    };\n    const isSelectedCell = cell => {\n      return !hasCurrent.value && (cell == null ? void 0 : cell.text) === 1 && cell.type === \"normal\" || cell.isCurrent;\n    };\n    const handleFocus = event => {\n      if (focusWithClick || hasCurrent.value || props.selectionMode !== \"date\") return;\n      handlePickDate(event, true);\n    };\n    const handleMouseDown = event => {\n      const target = event.target.closest(\"td\");\n      if (!target) return;\n      focusWithClick = true;\n    };\n    const handleMouseUp = event => {\n      const target = event.target.closest(\"td\");\n      if (!target) return;\n      focusWithClick = false;\n    };\n    const handlePickDate = (event, isKeyboardMovement = false) => {\n      const target = event.target.closest(\"td\");\n      if (!target) return;\n      const row = target.parentNode.rowIndex - 1;\n      const column = target.cellIndex;\n      const cell = rows.value[row][column];\n      if (cell.disabled || cell.type === \"week\") return;\n      const newDate = getDateOfCell(row, column);\n      if (props.selectionMode === \"range\") {\n        if (!props.rangeState.selecting || !props.minDate) {\n          emit(\"pick\", {\n            minDate: newDate,\n            maxDate: null\n          });\n          emit(\"select\", true);\n        } else {\n          if (newDate >= props.minDate) {\n            emit(\"pick\", {\n              minDate: props.minDate,\n              maxDate: newDate\n            });\n          } else {\n            emit(\"pick\", {\n              minDate: newDate,\n              maxDate: props.minDate\n            });\n          }\n          emit(\"select\", false);\n        }\n      } else if (props.selectionMode === \"date\") {\n        emit(\"pick\", newDate, isKeyboardMovement);\n      } else if (props.selectionMode === \"week\") {\n        const weekNumber = newDate.week();\n        const value = `${newDate.year()}w${weekNumber}`;\n        emit(\"pick\", {\n          year: newDate.year(),\n          week: weekNumber,\n          value,\n          date: newDate.startOf(\"week\")\n        });\n      } else if (props.selectionMode === \"dates\") {\n        const newValue = cell.selected ? castArray(props.parsedValue).filter(d => (d == null ? void 0 : d.valueOf()) !== newDate.valueOf()) : castArray(props.parsedValue).concat([newDate]);\n        emit(\"pick\", newValue);\n      }\n    };\n    const isWeekActive = cell => {\n      if (props.selectionMode !== \"week\") return false;\n      let newDate = props.date.startOf(\"day\");\n      if (cell.type === \"prev-month\") {\n        newDate = newDate.subtract(1, \"month\");\n      }\n      if (cell.type === \"next-month\") {\n        newDate = newDate.add(1, \"month\");\n      }\n      newDate = newDate.date(Number.parseInt(cell.text, 10));\n      if (props.parsedValue && !Array.isArray(props.parsedValue)) {\n        const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;\n        const weekDate = props.parsedValue.subtract(dayOffset, \"day\");\n        return weekDate.isSame(newDate, \"day\");\n      }\n      return false;\n    };\n    expose({\n      focus\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"table\", {\n        role: \"grid\",\n        \"aria-label\": unref(t)(\"el.datepicker.dateTablePrompt\"),\n        cellspacing: \"0\",\n        cellpadding: \"0\",\n        class: normalizeClass([unref(ns).b(), {\n          \"is-week-mode\": _ctx.selectionMode === \"week\"\n        }]),\n        onClick: handlePickDate,\n        onMousemove: handleMouseMove,\n        onMousedown: handleMouseDown,\n        onMouseup: handleMouseUp\n      }, [createElementVNode(\"tbody\", {\n        ref_key: \"tbodyRef\",\n        ref: tbodyRef\n      }, [createElementVNode(\"tr\", null, [_ctx.showWeekNumber ? (openBlock(), createElementBlock(\"th\", _hoisted_2, toDisplayString(unref(t)(\"el.datepicker.week\")), 1)) : createCommentVNode(\"v-if\", true), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(WEEKS), (week, key) => {\n        return openBlock(), createElementBlock(\"th\", {\n          key,\n          scope: \"col\",\n          \"aria-label\": unref(t)(\"el.datepicker.weeksFull.\" + week)\n        }, toDisplayString(unref(t)(\"el.datepicker.weeks.\" + week)), 9, _hoisted_3);\n      }), 128))]), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, rowKey) => {\n        return openBlock(), createElementBlock(\"tr\", {\n          key: rowKey,\n          class: normalizeClass([unref(ns).e(\"row\"), {\n            current: isWeekActive(row[1])\n          }])\n        }, [(openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, columnKey) => {\n          return openBlock(), createElementBlock(\"td\", {\n            key: `${rowKey}.${columnKey}`,\n            ref_for: true,\n            ref: el => isSelectedCell(cell) && (currentCellRef.value = el),\n            class: normalizeClass(getCellClasses(cell)),\n            \"aria-current\": cell.isCurrent ? \"date\" : void 0,\n            \"aria-selected\": cell.isCurrent,\n            tabindex: isSelectedCell(cell) ? 0 : -1,\n            onFocus: handleFocus\n          }, [createVNode(unref(ElDatePickerCell), {\n            cell\n          }, null, 8, [\"cell\"])], 42, _hoisted_4);\n        }), 128))], 2);\n      }), 128))], 512)], 42, _hoisted_1);\n    };\n  }\n});\nvar DateTable = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue\"]]);\nexport { DateTable as default };","map":{"version":3,"mappings":"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","names":["useNamespace","t","lang","useLocale","tbodyRef","ref","currentCellRef","lastRow","lastColumn","tableRows","focusWithClick","firstDayOfWeek","date","weekStart","WEEKS_CONSTANT","map","_","toLowerCase","computed","startDayOfMonth","subtract","day","concat","slice","flatten","rows","row","startOfMonth","daysInMonth","dateCountOfLastMonth","startOfMonthDay","dateCountOfMonth","props","selectionMode","castArray","cell","count","rowIndex","columnIndex","unref","days","offsetDay","numberOfDaysFromPreviousMonth","offset","text","type","disabledDate","cellClassName","selectedDate","shouldIncrement","setDateText","toDate","_selectedDate","d","dayjs","isCurrent","start","isActive","inRange","end","minDate","maxDate","rangeState","showWeekNumber","rows_","dateUnit","startDate","value","week","buildPickerTable","column","columnIndexOffset","nextEndDate","selecting","now","unit","relativeDateGetter","idx","add","setCellMetadata","args","setRowMetadata","watch","_a","getCellClasses","classes","push","customClass","tagName","target","emit","endDate","handlePickDate","event","newDate","year","isWeekActive"],"sources":["../../../../../../../packages/components/date-picker/src/date-picker-com/basic-date-table.vue"],"sourcesContent":["<template>\n  <table\n    role=\"grid\"\n    :aria-label=\"t('el.datepicker.dateTablePrompt')\"\n    cellspacing=\"0\"\n    cellpadding=\"0\"\n    :class=\"[ns.b(), { 'is-week-mode': selectionMode === 'week' }]\"\n    @click=\"handlePickDate\"\n    @mousemove=\"handleMouseMove\"\n    @mousedown=\"handleMouseDown\"\n    @mouseup=\"handleMouseUp\"\n  >\n    <tbody ref=\"tbodyRef\">\n      <tr>\n        <th v-if=\"showWeekNumber\" scope=\"col\">{{ t('el.datepicker.week') }}</th>\n        <th\n          v-for=\"(week, key) in WEEKS\"\n          :key=\"key\"\n          scope=\"col\"\n          :aria-label=\"t('el.datepicker.weeksFull.' + week)\"\n        >\n          {{ t('el.datepicker.weeks.' + week) }}\n        </th>\n      </tr>\n      <tr\n        v-for=\"(row, rowKey) in rows\"\n        :key=\"rowKey\"\n        :class=\"[ns.e('row'), { current: isWeekActive(row[1]) }]\"\n      >\n        <td\n          v-for=\"(cell, columnKey) in row\"\n          :key=\"`${rowKey}.${columnKey}`\"\n          :ref=\"(el) => isSelectedCell(cell) && (currentCellRef = el as HTMLElement)\"\n          :class=\"getCellClasses(cell)\"\n          :aria-current=\"cell.isCurrent ? 'date' : undefined\"\n          :aria-selected=\"cell.isCurrent\"\n          :tabindex=\"isSelectedCell(cell) ? 0 : -1\"\n          @focus=\"handleFocus\"\n        >\n          <el-date-picker-cell :cell=\"cell\" />\n        </td>\n      </tr>\n    </tbody>\n  </table>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, nextTick, ref, unref, watch } from 'vue'\nimport dayjs from 'dayjs'\nimport { flatten } from 'lodash-unified'\nimport { useLocale, useNamespace } from '@element-plus/hooks'\nimport { castArray } from '@element-plus/utils'\nimport { basicDateTableProps } from '../props/basic-date-table'\nimport { buildPickerTable } from '../utils'\nimport ElDatePickerCell from './basic-cell-render'\n\nimport type { Dayjs } from 'dayjs'\nimport type { DateCell } from '../date-picker.type'\n\nconst props = defineProps(basicDateTableProps)\nconst emit = defineEmits(['changerange', 'pick', 'select'])\n\nconst ns = useNamespace('date-table')\n\nconst { t, lang } = useLocale()\n\nconst tbodyRef = ref<HTMLElement>()\nconst currentCellRef = ref<HTMLElement>()\n// data\nconst lastRow = ref<number>()\nconst lastColumn = ref<number>()\nconst tableRows = ref<DateCell[][]>([[], [], [], [], [], []])\n\nlet focusWithClick = false\n\n// todo better way to get Day.js locale object\nconst firstDayOfWeek = (props.date as any).$locale().weekStart || 7\nconst WEEKS_CONSTANT = props.date\n  .locale('en')\n  .localeData()\n  .weekdaysShort()\n  .map((_) => _.toLowerCase())\n\nconst offsetDay = computed(() => {\n  // Sunday 7(0), cal the left and right offset days, 3217654, such as Monday is -1, the is to adjust the position of the first two rows of dates\n  return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek\n})\n\nconst startDate = computed(() => {\n  const startDayOfMonth = props.date.startOf('month')\n  return startDayOfMonth.subtract(startDayOfMonth.day() || 7, 'day')\n})\n\nconst WEEKS = computed(() => {\n  return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(\n    firstDayOfWeek,\n    firstDayOfWeek + 7\n  )\n})\n\nconst hasCurrent = computed<boolean>(() => {\n  return flatten(rows.value).some((row) => {\n    return row.isCurrent\n  })\n})\n\nconst days = computed(() => {\n  const startOfMonth = props.date.startOf('month')\n  const startOfMonthDay = startOfMonth.day() || 7 // day of first day\n  const dateCountOfMonth = startOfMonth.daysInMonth()\n\n  const dateCountOfLastMonth = startOfMonth.subtract(1, 'month').daysInMonth()\n\n  return {\n    startOfMonthDay,\n    dateCountOfMonth,\n    dateCountOfLastMonth,\n  }\n})\n\nconst selectedDate = computed(() => {\n  return props.selectionMode === 'dates'\n    ? (castArray(props.parsedValue) as Dayjs[])\n    : ([] as Dayjs[])\n})\n\n// Return value indicates should the counter be incremented\nconst setDateText = (\n  cell: DateCell,\n  {\n    count,\n    rowIndex,\n    columnIndex,\n  }: {\n    count: number\n    rowIndex: number\n    columnIndex: number\n  }\n): boolean => {\n  const { startOfMonthDay, dateCountOfMonth, dateCountOfLastMonth } =\n    unref(days)\n  const offset = unref(offsetDay)\n  if (rowIndex >= 0 && rowIndex <= 1) {\n    const numberOfDaysFromPreviousMonth =\n      startOfMonthDay + offset < 0\n        ? 7 + startOfMonthDay + offset\n        : startOfMonthDay + offset\n\n    if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {\n      cell.text = count\n      return true\n    } else {\n      cell.text =\n        dateCountOfLastMonth -\n        (numberOfDaysFromPreviousMonth - (columnIndex % 7)) +\n        1 +\n        rowIndex * 7\n      cell.type = 'prev-month'\n    }\n  } else {\n    if (count <= dateCountOfMonth) {\n      cell.text = count\n    } else {\n      cell.text = count - dateCountOfMonth\n      cell.type = 'next-month'\n    }\n    return true\n  }\n  return false\n}\n\nconst setCellMetadata = (\n  cell: DateCell,\n  {\n    columnIndex,\n    rowIndex,\n  }: {\n    columnIndex: number\n    rowIndex: number\n  },\n  count: number\n) => {\n  const { disabledDate, cellClassName } = props\n  const _selectedDate = unref(selectedDate)\n  const shouldIncrement = setDateText(cell, { count, rowIndex, columnIndex })\n\n  const cellDate = cell.dayjs!.toDate()\n  cell.selected = _selectedDate.find(\n    (d) => d.valueOf() === cell.dayjs!.valueOf()\n  )\n  cell.isSelected = !!cell.selected\n  cell.isCurrent = isCurrent(cell)\n  cell.disabled = disabledDate?.(cellDate)\n  cell.customClass = cellClassName?.(cellDate)\n  return shouldIncrement\n}\n\nconst setRowMetadata = (row: DateCell[]) => {\n  if (props.selectionMode === 'week') {\n    const [start, end] = props.showWeekNumber ? [1, 7] : [0, 6]\n    const isActive = isWeekActive(row[start + 1])\n    row[start].inRange = isActive\n    row[start].start = isActive\n    row[end].inRange = isActive\n    row[end].end = isActive\n  }\n}\n\nconst rows = computed(() => {\n  const { minDate, maxDate, rangeState, showWeekNumber } = props\n\n  const offset = offsetDay.value\n  const rows_ = tableRows.value\n  const dateUnit = 'day'\n  let count = 1\n\n  if (showWeekNumber) {\n    for (let rowIndex = 0; rowIndex < 6; rowIndex++) {\n      if (!rows_[rowIndex][0]) {\n        rows_[rowIndex][0] = {\n          type: 'week',\n          text: startDate.value.add(rowIndex * 7 + 1, dateUnit).week(),\n        }\n      }\n    }\n  }\n\n  buildPickerTable({ row: 6, column: 7 }, rows_, {\n    startDate: minDate,\n    columnIndexOffset: showWeekNumber ? 1 : 0,\n    nextEndDate:\n      rangeState.endDate ||\n      maxDate ||\n      (rangeState.selecting && minDate) ||\n      null,\n    now: dayjs().locale(unref(lang)).startOf(dateUnit),\n    unit: dateUnit,\n    relativeDateGetter: (idx: number) =>\n      startDate.value.add(idx - offset, dateUnit),\n    setCellMetadata: (...args) => {\n      if (setCellMetadata(...args, count)) {\n        count += 1\n      }\n    },\n\n    setRowMetadata,\n  })\n\n  return rows_\n})\n\nwatch(\n  () => props.date,\n  async () => {\n    if (tbodyRef.value?.contains(document.activeElement)) {\n      await nextTick()\n      currentCellRef.value?.focus()\n    }\n  }\n)\n\nconst focus = async () => {\n  currentCellRef.value?.focus()\n}\n\nconst isNormalDay = (type = '') => {\n  return ['normal', 'today'].includes(type)\n}\n\nconst isCurrent = (cell: DateCell): boolean => {\n  return (\n    props.selectionMode === 'date' &&\n    isNormalDay(cell.type) &&\n    cellMatchesDate(cell, props.parsedValue as Dayjs)\n  )\n}\n\nconst cellMatchesDate = (cell: DateCell, date: Dayjs) => {\n  if (!date) return false\n  return dayjs(date)\n    .locale(lang.value)\n    .isSame(props.date.date(Number(cell.text)), 'day')\n}\n\nconst getCellClasses = (cell: DateCell) => {\n  const classes: string[] = []\n  if (isNormalDay(cell.type) && !cell.disabled) {\n    classes.push('available')\n    if (cell.type === 'today') {\n      classes.push('today')\n    }\n  } else {\n    classes.push(cell.type!)\n  }\n\n  if (isCurrent(cell)) {\n    classes.push('current')\n  }\n\n  if (\n    cell.inRange &&\n    (isNormalDay(cell.type) || props.selectionMode === 'week')\n  ) {\n    classes.push('in-range')\n\n    if (cell.start) {\n      classes.push('start-date')\n    }\n\n    if (cell.end) {\n      classes.push('end-date')\n    }\n  }\n\n  if (cell.disabled) {\n    classes.push('disabled')\n  }\n\n  if (cell.selected) {\n    classes.push('selected')\n  }\n\n  if (cell.customClass) {\n    classes.push(cell.customClass)\n  }\n\n  return classes.join(' ')\n}\n\nconst getDateOfCell = (row: number, column: number) => {\n  const offsetFromStart =\n    row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value\n  return startDate.value.add(offsetFromStart, 'day')\n}\n\nconst handleMouseMove = (event: MouseEvent) => {\n  if (!props.rangeState.selecting) return\n\n  let target = event.target as HTMLElement\n  if (target.tagName === 'SPAN') {\n    target = target.parentNode?.parentNode as HTMLElement\n  }\n  if (target.tagName === 'DIV') {\n    target = target.parentNode as HTMLElement\n  }\n  if (target.tagName !== 'TD') return\n\n  const row = (target.parentNode as HTMLTableRowElement).rowIndex - 1\n  const column = (target as HTMLTableCellElement).cellIndex\n\n  // can not select disabled date\n  if (rows.value[row][column].disabled) return\n\n  // only update rangeState when mouse moves to a new cell\n  // this avoids frequent Date object creation and improves performance\n  if (row !== lastRow.value || column !== lastColumn.value) {\n    lastRow.value = row\n    lastColumn.value = column\n    emit('changerange', {\n      selecting: true,\n      endDate: getDateOfCell(row, column),\n    })\n  }\n}\n\nconst isSelectedCell = (cell: DateCell) => {\n  return (\n    (!hasCurrent.value && cell?.text === 1 && cell.type === 'normal') ||\n    cell.isCurrent\n  )\n}\n\nconst handleFocus = (event: FocusEvent) => {\n  if (focusWithClick || hasCurrent.value || props.selectionMode !== 'date')\n    return\n  handlePickDate(event, true)\n}\n\nconst handleMouseDown = (event: MouseEvent) => {\n  const target = (event.target as HTMLElement).closest('td')\n  if (!target) return\n  focusWithClick = true\n}\n\nconst handleMouseUp = (event: MouseEvent) => {\n  const target = (event.target as HTMLElement).closest('td')\n  if (!target) return\n  focusWithClick = false\n}\n\nconst handlePickDate = (\n  event: FocusEvent | MouseEvent,\n  isKeyboardMovement = false\n) => {\n  const target = (event.target as HTMLElement).closest('td')\n\n  if (!target) return\n\n  const row = (target.parentNode as HTMLTableRowElement).rowIndex - 1\n  const column = (target as HTMLTableCellElement).cellIndex\n  const cell = rows.value[row][column]\n\n  if (cell.disabled || cell.type === 'week') return\n\n  const newDate = getDateOfCell(row, column)\n\n  if (props.selectionMode === 'range') {\n    if (!props.rangeState.selecting || !props.minDate) {\n      emit('pick', { minDate: newDate, maxDate: null })\n      emit('select', true)\n    } else {\n      if (newDate >= props.minDate) {\n        emit('pick', { minDate: props.minDate, maxDate: newDate })\n      } else {\n        emit('pick', { minDate: newDate, maxDate: props.minDate })\n      }\n      emit('select', false)\n    }\n  } else if (props.selectionMode === 'date') {\n    emit('pick', newDate, isKeyboardMovement)\n  } else if (props.selectionMode === 'week') {\n    const weekNumber = newDate.week()\n    const value = `${newDate.year()}w${weekNumber}`\n    emit('pick', {\n      year: newDate.year(),\n      week: weekNumber,\n      value,\n      date: newDate.startOf('week'),\n    })\n  } else if (props.selectionMode === 'dates') {\n    const newValue = cell.selected\n      ? castArray(props.parsedValue).filter(\n          (d) => d?.valueOf() !== newDate.valueOf()\n        )\n      : castArray(props.parsedValue).concat([newDate])\n    emit('pick', newValue)\n  }\n}\n\nconst isWeekActive = (cell: DateCell) => {\n  if (props.selectionMode !== 'week') return false\n  let newDate = props.date.startOf('day')\n\n  if (cell.type === 'prev-month') {\n    newDate = newDate.subtract(1, 'month')\n  }\n\n  if (cell.type === 'next-month') {\n    newDate = newDate.add(1, 'month')\n  }\n\n  newDate = newDate.date(Number.parseInt(cell.text as any, 10))\n\n  if (props.parsedValue && !Array.isArray(props.parsedValue)) {\n    const dayOffset = ((props.parsedValue.day() - firstDayOfWeek + 7) % 7) - 1\n    const weekDate = props.parsedValue.subtract(dayOffset, 'day')\n    return weekDate.isSame(newDate, 'day')\n  }\n  return false\n}\n\ndefineExpose({\n  /**\n   * @description focus on current cell\n   */\n  focus,\n})\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}